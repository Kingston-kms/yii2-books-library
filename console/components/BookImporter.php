<?phpnamespace console\components;use common\models\Author;use common\models\Book;use common\models\BookAuthor;use common\models\BookCategory;use common\models\Category;use common\models\Status;use GuzzleHttp\Client;use GuzzleHttp\Exception\GuzzleException;use yii\base\Exception;use yii\base\InvalidConfigException;use yii\helpers\FileHelper;use yii\helpers\Url;use yii\validators\UrlValidator;class BookImporter extends \yii\base\Component{    /**     * @var string     * Link to JSON file     */    public string $url = "";    private Client $client;    public function __construct($config = [])    {        parent::__construct($config);    }    public function init()    {        parent::init();        $this->validateUrl();    }    private function validateUrl()    {        if (empty($this->url)) {            throw new InvalidConfigException("Missing required param `url`");        }        $validator = new UrlValidator();        if ($validator->validate($this->url) === false) {            throw new InvalidConfigException("Invalid url");        }        $this->initHttpClient();    }    private function initHttpClient()    {        $this->client = new Client([            'verify' => \Yii::getAlias('@certFile')        ]);    }    public function parse()    {        try {            $response = $this->client->request("GET", $this->url);            $content = json_decode($response->getBody()->getContents(), true);            $statuses = Status::getStatusListWithId();            $revertedStatuses = array_flip($statuses);            $categoryList = Category::getCategoryListWithId();            $revertedCategories = array_flip($categoryList);            $authors = Author::getAuthorListWithId();            $revertedAuthors = array_flip($authors);            foreach ($content as $book) {                if (isset($data['isbn']) && Book::hasBookByIsbn($data['isbn']))                        continue;                if (!in_array($book['status'], array_keys($revertedStatuses))) {                    $newStatusId = Status::addStatus($book['status']);                    $revertedStatuses[$book['status']] = $newStatusId;                }                $book['status'] = $revertedStatuses[$book['status']];                $this->remapColumns($book);                $this->formatPublishedDate($book);                $this->downloadImage($book);                $bookInstance = Book::addBook($book);                if (!empty($bookInstance)) {                    $this->parseCategories($bookInstance->id, $revertedCategories, $book);                    $this->parseAuthors($bookInstance->id, $revertedAuthors, $book);                }            }        } catch (\GuzzleHttp\Exception\GuzzleException $e) {            var_dump($e->getMessage());        }    }    private function downloadImage(&$book)    {        if (empty($book['thumbnail_url'])) {            return;        }        $directory = \Yii::getAlias('@imagePath');        try {            FileHelper::createDirectory($directory);        } catch (Exception $e) {        }        $imageName = basename($book['thumbnail_url']);        $fileName = FileHelper::normalizePath($directory . DIRECTORY_SEPARATOR . $imageName);        try {            if (file_exists($fileName)) {                $book['thumbnail_url'] = $imageName;                return;            }            $this->client->request("GET", $book['thumbnail_url'], ['sink' => $fileName]);            $book['thumbnail_url'] = $imageName;        } catch (GuzzleException $e) {            FileHelper::unlink($fileName);            \Yii::error($e->getMessage());            \Yii::error($e->getTraceAsString());        }    }    /**     * @param $newBookId     * @param $categories     * @param $book     * @return void     */    private function parseCategories($newBookId,&$categories,&$book): void    {        if (empty($book['categories'])) {            BookCategory::addBookCategory($newBookId, $categories[Category::DEFAULT_CATEGORY_NAME]);            return;        }        foreach ($book['categories'] as $category) {            if (empty($category)) continue;            if (!in_array($category, array_keys($categories))) {                $newCategoryId = Category::addCategory($category);                $categories[$category] = $newCategoryId;            }            BookCategory::addBookCategory($newBookId, $categories[$category]);        }    }    private function parseAuthors($newBookId, &$authors, &$book)    {        if (empty($book['authors'])) {            return;        }        foreach ($book['authors'] as $author) {            if (empty($author)) continue;            if (!in_array($author, array_keys($authors))) {                $newAuthorId = Author::addAuthor($author);                $authors[$author] = $newAuthorId;            }            BookAuthor::addBookAuthor($newBookId, $authors[$author]);        }    }    private function remapColumns(&$data) {        foreach (Book::$columnMapping as $source => $dest) {            if (isset($data[$source])) {                $data[$dest] = $data[$source];                unset($data[$source]);            }        }    }    private function formatPublishedDate(&$book) {        if (!isset($book['published_date'], $book['published_date']['$date'])) return;        $time = strtotime($book['published_date']['$date']);        if ($time === false) {            unset($book['published_date']);            return;        }        $date = \DateTime::createFromFormat("U", $time, new \DateTimeZone("UTC"));        $book['published_date'] = $date->format("Y-m-d H:i:s");    }}